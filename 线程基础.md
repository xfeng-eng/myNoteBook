---
typora-copy-images-to: upload
---

# 多线程

## 一、线程相关概念

### 程序（program）

是为了完成特定任务，用某种语言编写的一组指令的集合

简单的来说：就是我们写的代码

### 进程

1. 进程是指运行中的程序，比我我们启动了qq，就启动了一个进程，操作系统就会为该进程分配内存空间，当我们启动浏览器，又启动了一个进程，操作系统将为浏览器分配新的内存空间
2. 进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程，有它自身的产生、存在和消亡的过程

### 线程

1. 线程由进程创建，是进程的一个实体
2. 一个进程可以拥有多个线程
3. 单线程：同一时刻，只允许执行一个线程
4. 多线程：同一时刻，可以执行多个线程
5. 并发：同一时刻，多个任务交替执行，造成 假的同时执行错觉，简单来说，单核cpu实现的多任务就是并发
6. 并行：同一时刻，多个任务同时执行。多核cpu可以实现并行

## 二、线程的基本使用

### 创建线程的三种基本方式

 **继承Thread类创建线程类**

- 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
- 创建Thread子类的实例，即创建了线程对象。
- 调用线程对象的start()方法来启动该线程。

 **通过Runnable接口创建线程类**

- 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
- 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
- 调用线程对象的start()方法来启动该线程。

**通过Callable和Future创建线程**

- 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
- 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
- 使用FutureTask对象作为Thread对象的target创建并启动新线程。
- 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。



### **线程的 run()和 start()的区别**

每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。

start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。

run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。

![20200114205204447](https://s2.loli.net/2022/05/24/QhLfTRxwgaPboqd.png)

```java
package thread;

/**
 * @program: study
 * @description: 创建线程的两种基本方式
 * @author: xiongfeng
 * @create: 2022-05-24 12:37
 **/
public class Thread02 {
    public static void main(String[] args) {
        //通过继承Thread类创建线程
        // 创建 Cat 对象，可以当做线程使用
        Cat cat = new Cat();
        cat.start();
        /*
        (1)
        public synchronized void start() {
        start0();
        }
        (2)
        //start0() 是本地方法，是 JVM 调用, 底层是 c/c++实现
        //真正实现多线程的效果， 是 start0(), 而不是 run
        private native void start0();
        */


        //通过实现Runnable接口创建线程
        //dog.start(); 这里不能调用 start
        Dog dog = new Dog();
        //创建了 Thread 对象，把 dog 对象(实现 Runnable),放入 Thread
        /*
         这里底层使用了设计模式：代理模式

         private Runnable target;

        public Thread(Runnable target) {
            init(null, target, "Thread-" + nextThreadNum(), 0);
        }

        再通过Thread类中start()方法调用start01()，最终调用Dog类的run方法
         */

        Thread thread = new Thread(dog);
        thread.start();

    }
}


class Dog implements Runnable {
    int num = 0;

    @Override
    public void run() {
        while (true) {
            System.out.println("汪汪汪" + (num++) + Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (num == 10) {
                break;
            }
        }
    }
}

class Cat extends Thread {
    int num;

    @Override
    public void run() {
        super.run();
        while (true) {
            System.out.println("喵喵喵" + (num++) + Thread.currentThread().getName());

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (num == 10) {
                break;
            }
        }
    }
}
```

### 继承 Thread vs 实现 Runnable 的区别

1. 从java的设计来看，通过继承Thread类或者实现Runnable接口来创建线程本质上没有区别，Thread类本身就实现了Runnable接口
2. 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制

```java
Cat cat = new Cat("喵喵喵");
Thread thread01 = new Thread(cat);
Thread thread02 = new Thread(cat);
thread01.start();
thread02.start();
```

### 线程终止

1. 线程完成任务后，会自动推出
2. 还可以通过**使用变量**来控制run方法退出，来停止线程，即**通知方式**，例如flag =true

### 线程常用的方法

1. seName

2. getName

3. start

4. run

5. setPriority //更改线程的优先级

6. getPriority

7. sleep //让当前正在执行的线程休眠指定毫秒，不释放同步锁 静态方法

8. interrupt //中断线程，一般用于中断正在执行的线程

9. yield 线程的礼让，让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定成功 静态方法

10. join 线程插队，插队的线程一旦插队成功，则会先执行完插入线程的所有任务

    ```java
    package thread;
    
    /**
     * @program: study
     * @description: yield 和 join
     * @author: xiongfeng
     * @create: 2022-05-24 12:37
     **/
    public class Thread02 {
        public static void main(String[] args) {
            //通过继承Thread类创建线程
            // 创建 Cat 对象，可以当做线程使用
            Cat cat = new Cat();
            cat.start();
            try {
                cat.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
    
            Dog dog = new Dog();
            Thread thread = new Thread(dog);
            thread.start();
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Thread.yield();
            System.out.println(Thread.currentThread().getName() + "结束");
        }
    }
    ```

    

### 用户线程和守护线程

1. 用户线程：也叫工作线程，当线程的**任务执行完毕**或**通知方式** 才结束
2. 守护线程：一般时为工作线程服务的，当所有的用户线程结束，守护线程自动结束
3. 常见的守护线程：垃圾回收机制

```java
package thread;

/**
 * @program: study
 * @description: 守护线程
 * @author: xiongfeng
 * @create: 2022-05-30 14:36
 **/
public class DaemonThread {
    public static void main(String[] args) throws InterruptedException {
        T t = new T();
        Thread thread = new Thread(t);
        
        //将子线程设置为守护线程后，只要主线程结束，子线程也会自动结束
        thread.setDaemon(true);

        thread.start();
        for(int i = 0; i<5;i++){
            Thread.sleep(500);
            System.out.println("主线程"+Thread.currentThread().getName()+"正在陨星");
        }
    }
}
class T implements Runnable{
    @Override
    public void run() {
        int i = 0;
        while(i<50){
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("子线程"+Thread.currentThread().getName()+"正在陨星");
            i++;
        }
    }
}
```

